'use strict';
// Code extracted from https://github.com/openstf/adbkit-apkreader
// Generated by CoffeeScript 1.10.0
const BinaryXmlParser = require('./binaryxml');
const XmlParser = require('./xml');
const utils = require('./utils');

// const NS_ANDROID = 'http://schemas.android.com/apk/res/android';

const INTENT_MAIN = 'android.intent.action.MAIN';

const CATEGORY_LAUNCHER = 'android.intent.category.LAUNCHER';

class ManifestParser {
  constructor(buffer, options) {
    this.buffer = buffer;

    const firstByte = buffer[0];

    if (firstByte === 60 || firstByte === '<') {
      this.xmlParser = new XmlParser(this.buffer.toString());
    } else {
      this.xmlParser = new BinaryXmlParser(this.buffer);
    }

    this.options = options || {};
  }

  collapseAttributes(element, ignoreAttrs) {
    const collapsed = Object.create(null);
    const ref = element.attributes;
    for (let i = 0, len = ref.length; i < len; i++) {
      const attr = ref[i];

      let isInIgnoreList;
      if (ignoreAttrs && utils.isArray(ignoreAttrs)) {
        isInIgnoreList = ignoreAttrs.some(ignoreAttrName => {
          if (attr.name === ignoreAttrName) {
            return true;
          }
          return false;
        });
      }

      if (!isInIgnoreList) {
        collapsed[attr.name] = attr.typedValue.value;
      }
    }
    return collapsed;
  }

  parseIntents(element, target) {
    target.intentFilters = [];
    target.metaData = [];
    return element.childNodes.forEach((_this => {
      return element => {
        switch (element.nodeName) {
          case 'intent-filter': {
            const intentFilter = _this.collapseAttributes(element);
            intentFilter.actions = [];
            intentFilter.categories = [];
            intentFilter.data = [];
            element.childNodes.forEach(element => {
              switch (element.nodeName) {
                case 'action':
                  return intentFilter.actions.push(_this.collapseAttributes(element));
                case 'category':
                  return intentFilter.categories.push(_this.collapseAttributes(element));
                case 'data':
                  return intentFilter.data.push(_this.collapseAttributes(element));
                default:
                  return null;
              }
            });
            return target.intentFilters.push(intentFilter);
          }
          case 'meta-data':
            return target.metaData.push(_this.collapseAttributes(element));
          default:
            return null;
        }
      };
    })(this));
  }

  parseApplication(element, ignoreAttrs) {
    const app = this.collapseAttributes(element);
    app.activities = [];
    app.activityAliases = [];
    app.launcherActivities = [];
    app.services = [];
    app.receivers = [];
    app.providers = [];
    app.usesLibraries = [];
    element.childNodes.forEach((_this => {
      return element => {
        let isInIgnoreList;
        if (utils.isArray(ignoreAttrs)) {
          isInIgnoreList = ignoreAttrs.some(attrName => {
            return attrName === element.nodeName;
          });
        }

        if (isInIgnoreList) return;

        switch (element.nodeName) {
          case 'activity': {
            const activity = _this.collapseAttributes(element);
            _this.parseIntents(element, activity);
            app.activities.push(activity);
            if (_this.isLauncherActivity(activity)) {
              return app.launcherActivities.push(activity);
            }
            break;
          }

          case 'activity-alias': {
            const activityAlias = _this.collapseAttributes(element);
            _this.parseIntents(element, activityAlias);
            app.activityAliases.push(activityAlias);
            if (_this.isLauncherActivity(activityAlias)) {
              return app.launcherActivities.push(activityAlias);
            }
            break;
          }
          case 'service': {
            const service = _this.collapseAttributes(element);
            _this.parseIntents(element, service);
            return app.services.push(service);
          }
          case 'receiver': {
            const receiver = _this.collapseAttributes(element);
            _this.parseIntents(element, receiver);
            return app.receivers.push(receiver);
          }
          case 'provider': {
            const provider = _this.collapseAttributes(element);
            provider.grantUriPermissions = [];
            provider.metaData = [];
            provider.pathPermissions = [];
            element.childNodes.forEach(element => {
              switch (element.nodeName) {
                case 'grant-uri-permission':
                  return provider.grantUriPermissions.push(_this.collapseAttributes(element));
                case 'meta-data':
                  return provider.metaData.push(_this.collapseAttributes(element));
                case 'path-permission':
                  return provider.pathPermissions.push(_this.collapseAttributes(element));
                default:
                  break;
              }
            });
            return app.providers.push(provider);
          }
          case 'uses-library':
            return app.usesLibraries.push(_this.collapseAttributes(element));
          default:
            return null;
        }
      };
    })(this));
    return app;
  }

  isLauncherActivity(activity) {
    return activity.intentFilters.some(filter => {
      const hasMain = filter.actions.some(action => {
        return action.name === INTENT_MAIN;
      });
      if (!hasMain) {
        return false;
      }
      return filter.categories.some(category => {
        return category.name === CATEGORY_LAUNCHER;
      });
    });
  }

  parse() {
    const document = this.xmlParser.parse();
    const manifest = this.collapseAttributes(document);
    manifest.usesPermissions = [];
    manifest.permissions = [];
    manifest.permissionTrees = [];
    manifest.permissionGroups = [];
    manifest.instrumentation = null;
    manifest.usesSdk = null;
    manifest.usesConfiguration = null;
    manifest.usesFeatures = [];
    manifest.supportsScreens = null;
    manifest.compatibleScreens = [];
    manifest.supportsGlTextures = [];
    manifest.application = Object.create(null);
    const ignoreMap = {};
    if (this.options.ignore && this.options.ignore.length) {
      this.options.ignore.forEach(ignore => {
        const nodeKeys = ignore.split('.');
        const nodeName = nodeKeys[0];
        const attrName = nodeKeys[1];

        if (!ignoreMap[nodeName]) {
          ignoreMap[nodeName] = [];
        }

        if (attrName) {
          ignoreMap[nodeName].push(attrName);
        }
      });
    }

    document.childNodes.forEach((_this => {
      return element => {
        let ignoreAttrs;
        if (element.nodeName in ignoreMap) {
          if (!ignoreMap[element.nodeName].length) {
            return;
          }
          ignoreAttrs = ignoreMap[element.nodeName];
        }
        switch (element.nodeName) {
          case 'uses-permission':
            return manifest.usesPermissions.push(_this.collapseAttributes(element, ignoreAttrs));
          case 'permission':
            return manifest.permissions.push(_this.collapseAttributes(element, ignoreAttrs));
          case 'permission-tree':
            return manifest.permissionTrees.push(_this.collapseAttributes(element, ignoreAttrs));
          case 'permission-group':
            return manifest.permissionGroups.push(_this.collapseAttributes(element, ignoreAttrs));
          case 'instrumentation':
            manifest.instrumentation = _this.collapseAttributes(element, ignoreAttrs);
            return manifest.instrumentation;
          case 'uses-sdk':
            manifest.usesSdk = _this.collapseAttributes(element, ignoreAttrs);
            return manifest.usesSdk;
          case 'uses-configuration':
            manifest.usesConfiguration = _this.collapseAttributes(element, ignoreAttrs);
            return manifest.usesConfiguration;
          case 'uses-feature':
            return manifest.usesFeatures.push(_this.collapseAttributes(element, ignoreAttrs));
          case 'supports-screens':
            manifest.supportsScreens = _this.collapseAttributes(element, ignoreAttrs);
            return manifest.supportsScreens;
          case 'compatible-screens':
            return element.childNodes.forEach(screen => {
              return manifest.compatibleScreens.push(_this.collapseAttributes(screen, ignoreAttrs));
            });
          case 'supports-gl-texture':
            return manifest.supportsGlTextures.push(_this.collapseAttributes(element, ignoreAttrs));
          case 'application':
            manifest.application = _this.parseApplication(element, ignoreAttrs);
            return manifest.application;
          default:
            return null;
        }
      };
    })(this));
    return manifest;
  }
}

module.exports = ManifestParser;
